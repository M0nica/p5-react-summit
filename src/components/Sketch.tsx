import { type P5CanvasInstance, type Sketch } from '@p5-wrapper/react';
import { lightBg } from './utils';
import {
  type Pattern,
  type MySketchProps,
  type Shape,
  type Colors,
} from './types';
import { defaultInputValues } from './demo';
import { convertStringToSeedNumber, computeCanvasDimensions } from './utils';

let originalSize = 35;
const weight = 8;

function drawRectangle(
  p5: P5CanvasInstance<MySketchProps>,
  width: number,
  name: string,
  colors: Colors,
  size: number
) {
  const { fromColor, toColor, bgColor } = colors;
  p5.textSize(width > 750 ? originalSize * 0.5 : originalSize * 0.45);

  // draw a rectangle at top of canvas
  p5.noStroke();
  p5.fill(colors.fromColor);
  p5.rect(0, 0, width, size);

  // write the name in the rectangle
  p5.fill(bgColor);
  p5.textAlign(p5.CENTER, p5.CENTER);
  p5.text(
    `${
      name ? `Generated by ${name} at` : `Sketching with Code at`
    } React Summit 2024`,
    width / 2,
    size / 2
  );

  //draw  three circles to represent the three colors in palette
  if (width > 600) {
    p5.stroke(lightBg);

    [fromColor, toColor, bgColor].forEach((color, index) => {
      p5.fill(color);
      p5.circle(
        width - (index + 1) * originalSize,
        originalSize / 2,
        originalSize * 0.5
      );
    });
  }
}
function drawTiles(
  p5: P5CanvasInstance<MySketchProps>,
  width: number,
  height: number,
  originalSize: number,
  inputValues: {
    size: number;
    colors: Colors;
    patternMode: Pattern;
    showGridLines: boolean;
    artMode: Shape;
  }
) {
  const { colors, patternMode, showGridLines, size, artMode } = inputValues;
  const { fromColor, toColor } = colors;

  const from = p5.color(fromColor);
  const to = p5.color(toColor);

  const tile = generateTile(p5, showGridLines, artMode);

  for (var i = 1; i <= width + size; i += size) {
    for (var j = 1; j <= height + size; j += size) {
      p5.push();
      p5.translate(i, j);
      var angle = (p5.TWO_PI * p5.int(p5.random(1, 5))) / 4;
      p5.rotate(angle);
      p5.tint(
        p5.lerpColor(
          from,
          to,
          patternMode === 'gradient' ? j / height : p5.random(1)
        )
      );
      p5.scale(size / originalSize);
      p5.image(tile, 0, 0);
      p5.pop();
    }
  }
}

function generateTile(
  p5: P5CanvasInstance<MySketchProps>,
  showGridLines: boolean,
  artMode: Shape
) {
  let pg;

  pg = p5.createGraphics(originalSize + 2, originalSize + 2);

  if (showGridLines) {
    pg.noFill();
    pg.stroke(lightBg);
    pg.strokeWeight(weight * 0.25);
    pg.strokeCap(p5.ROUND);
    pg.square(0, 0, pg.height);
    p5.noStroke();
  }

  pg.strokeWeight(weight);
  pg.strokeCap(p5.ROUND);
  if (artMode == 'round') {
    pg.noFill();
    pg.stroke('255');
  } else {
    pg.fill(255);
    pg.noStroke();
  }

  pg.arc(0, 0, pg.width, pg.height, 0, p5.PI / 2);
  pg.arc(pg.width, pg.height, pg.width, pg.height, p5.PI, p5.PI + p5.PI / 2);

  return pg;
}

export const sketch: Sketch<MySketchProps> = (p5) => {
  let inputValues = defaultInputValues;

  p5.updateWithProps = (props) => {
    inputValues = props;

    if (inputValues.isSavingImage) {
      p5.saveCanvas('myCanvas', 'jpg');
    }

    p5.redraw();
  };

  p5.setup = () => {
    const { height, width } = computeCanvasDimensions(
      p5.windowWidth,
      p5.windowHeight
    );
    p5.createCanvas(width, height);
    p5.imageMode(p5.CENTER);
    p5.textFont('Pixelify Sans Variable');
  };

  p5.windowResized = () => {
    const { width, height } = computeCanvasDimensions(
      p5.windowWidth,
      p5.windowHeight
    );
    p5.resizeCanvas(width, height);
  };

  p5.draw = () => {
    const { colors } = inputValues;
    const { bgColor } = colors;

    p5.background(bgColor);

    p5.randomSeed(convertStringToSeedNumber(inputValues.name));

    p5.noLoop();

    drawTiles(
      p5 as P5CanvasInstance,
      p5.width,
      p5.height,
      originalSize,
      inputValues
    );

    if (inputValues.showBanner) {
      drawRectangle(
        p5 as P5CanvasInstance,
        p5.width,
        inputValues.name,
        inputValues.colors,
        inputValues.size
      );
    }
  };
};
